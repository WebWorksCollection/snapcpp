// Snap Websites Server -- snap websites server
// Copyright (C) 2011-2014  Made to Order Software Corp.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#pragma once

#include "snap_child.h"
#include "snap_expr.h"
#include "plugins.h"
#include "snap_listen_thread.h"

#include <advgetopt/advgetopt.h>

#include <QDomDocument>


#define    SNAPWEBSITES_VERSION_MAJOR   @SNAPWEBSITES_VERSION_MAJOR@
#define    SNAPWEBSITES_VERSION_MINOR   @SNAPWEBSITES_VERSION_MINOR@
#define    SNAPWEBSITES_VERSION_PATCH   @SNAPWEBSITES_VERSION_PATCH@
#define    SNAPWEBSITES_VERSION_STRING  "@SNAPWEBSITES_VERSION_MAJOR@.@SNAPWEBSITES_VERSION_MINOR@.@SNAPWEBSITES_VERSION_PATCH@"

namespace snap
{

enum name_t
{
    SNAP_NAME_SERVER,           // The name of the Snap! Server
    SNAP_NAME_CONTEXT,          // Cassandra Keyspace
    SNAP_NAME_INDEX,            // Row used for the domains & websites index
    SNAP_NAME_DOMAINS,          // Cassandra Table used for domains
    SNAP_NAME_WEBSITES,         // Cassandra Table used for websites
    SNAP_NAME_SITES,            // Cassandra Table used for sites (one site per row)
    SNAP_NAME_CORE_ADMINISTRATOR_EMAIL,
    SNAP_NAME_CORE_LAST_UPDATED,
    SNAP_NAME_CORE_HTTP_USER_AGENT,
    SNAP_NAME_CORE_SITE_NAME,
    SNAP_NAME_CORE_SITE_SHORT_NAME,
    SNAP_NAME_CORE_SITE_LONG_NAME,
    SNAP_NAME_CORE_PLUGINS,
    SNAP_NAME_CORE_REDIRECT,
    SNAP_NAME_CORE_RULES,
    SNAP_NAME_CORE_ORIGINAL_RULES,
    SNAP_NAME_CORE_PLUGIN_THRESHOLD,
    SNAP_NAME_CORE_COOKIE_DOMAIN,
    SNAP_NAME_CORE_USER_COOKIE_NAME
};
char const *get_name(name_t name) __attribute__ ((const));



class snapwebsites_exception : public snap_exception
{
public:
    snapwebsites_exception(char const *       whatmsg) : snap_exception("snap_thread", whatmsg) {}
    snapwebsites_exception(std::string const& whatmsg) : snap_exception("snap_thread", whatmsg) {}
    snapwebsites_exception(QString const&     whatmsg) : snap_exception("snap_thread", whatmsg) {}
};

class snapwebsites_exception_invalid_parameters : public snapwebsites_exception
{
public:
    snapwebsites_exception_invalid_parameters(char const *       whatmsg) : snapwebsites_exception(whatmsg) {}
    snapwebsites_exception_invalid_parameters(std::string const& whatmsg) : snapwebsites_exception(whatmsg) {}
    snapwebsites_exception_invalid_parameters(QString const&     whatmsg) : snapwebsites_exception(whatmsg) {}
};


class permission_error_callback
{
public:
    virtual                 ~permission_error_callback() {}

    virtual void            on_error(snap_child::http_code_t err_code, QString const& err_name, QString const& err_description, QString const& err_details) = 0;
    virtual void            on_redirect(QString const& err_name, QString const& err_description, QString const& err_details, bool err_security, QString const& path, snap_child::http_code_t http_code) = 0;
};

// a simple specialization of the permission_error_callback that quiet
// the errors so they don't get in the way
class quiet_error_callback : public permission_error_callback
{
public:
                    quiet_error_callback(snap_child *snap, bool log);

    virtual void    on_error(snap_child::http_code_t err_code, QString const& err_name, QString const& err_description, QString const& err_details);
    virtual void    on_redirect(QString const& err_name, QString const& err_description, QString const& err_details, bool err_security, QString const& path, snap_child::http_code_t http_code);

    void            clear_error();
    bool            has_error() const;

private:
    zpsnap_child_t              f_snap;
    controlled_vars::mbool_t    f_log;
    controlled_vars::fbool_t    f_error;
};



class server : public plugins::plugin
{
public:
    class backend_action
    {
    public:
        virtual         ~backend_action() {}
        virtual void    on_backend_action(QString const& action) = 0;
    };

    class secure_field_flag_t
    {
    public:
                        secure_field_flag_t()
                            //: f_secure(false) -- auto-init
                        {
                        }

        bool            is_secure() const { return f_secure; }
        void            mark_as_secure() { f_secure = true; }

    private:
        // prevent copies or a user could reset the flag!
                        secure_field_flag_t(secure_field_flag_t const& rhs) = delete;
                        secure_field_flag_t& operator = (secure_field_flag_t const& rhs) = delete;

        controlled_vars::fbool_t    f_secure;
    };


    typedef QMap<QString, backend_action *> backend_action_map_t;
    typedef std::shared_ptr<server>         pointer_t;

    static pointer_t instance();
    virtual ~server();

    static const char *version();
    static int version_major();
    static int version_minor();
    static int version_patch();
    virtual QString description() const;
    virtual int64_t do_update(int64_t last_updated);

    void usage();
    void setup_as_backend();
    bool is_debug() const { return f_debug; }
    bool is_foreground() const { return f_foreground; }
    bool is_backend() const { return f_backend; }
    void config( int argc, char *argv[] );
    QString get_parameter(QString const& param_name) const;
    void exit(int code);
    void prepare_qtapp( int argc, char *argv[] );
    void close_qtapp();
    void prepare_cassandra();
    QtCassandra::QCassandraTable::pointer_t create_table(QtCassandra::QCassandraContext::pointer_t context, QString table_name, QString comment);
    void detach();
    void listen();
    void backend();
    int cassandra_port() const { return f_cassandra_port; }
    const QString& cassandra_host() const { return f_cassandra_host; }
    void udp_ping(char const *name, char const *message = "PING");

    unsigned long connections_count();

    std::string servername() const;

    typedef QSharedPointer<udp_client_server::udp_server> udp_server_t;
    static udp_server_t udp_get_server ( const QString& udp_addr_port );
    static void         udp_ping_server( const QString& udp_addr_port, char const *message = "PING" );

    SNAP_SIGNAL(bootstrap, (snap_child *snap), (snap));
    SNAP_SIGNAL(init, (), ());
    SNAP_SIGNAL(update, (int64_t last_updated), (last_updated));
    SNAP_SIGNAL(process_cookies, (), ());
    SNAP_SIGNAL(attach_to_session, (), ());
    SNAP_SIGNAL(detach_from_session, (), ());
    SNAP_SIGNAL(define_locales, (QString& locales), (locales));
    SNAP_SIGNAL(process_post, (QString const& url), (url));
    SNAP_SIGNAL(execute, (QString const& url), (url));
    SNAP_SIGNAL(register_backend_action, (backend_action_map_t& actions), (actions));
    SNAP_SIGNAL(backend_process, (), ());
    SNAP_SIGNAL(save_content, (), ());
    SNAP_SIGNAL(xss_filter, (QDomNode& node,
                             QString const& accepted_tags,
                             QString const& accepted_attributes),
                            (node, accepted_tags, accepted_attributes));
    SNAP_SIGNAL(improve_signature, (QString const& path, QString& signature),
                                   (path, signature));
    SNAP_SIGNAL(load_file, (snap_child::post_file_t& file, bool& found), (file, found));
    SNAP_SIGNAL(cell_is_secure, (QString const& table, QString const& row, QString const& cell, secure_field_flag_t& secure), (table, row, cell, secure));
    SNAP_SIGNAL(add_snap_expr_functions, (snap_expr::functions_t& functions), (functions));

private:
    typedef QMap<QString, QString>                parameter_map_t;
    typedef std::shared_ptr<advgetopt::getopt>    getopt_ptr_t;

    server();

    static void sighandler( int sig );

    void process_connection(int socket);
    void stop_thread_func();

    static pointer_t                        g_instance;

    std::string                             f_servername;
    controlled_vars::fbool_t                f_debug;
    controlled_vars::fbool_t                f_foreground;
    controlled_vars::fbool_t                f_backend;
    QString                                 f_config;
    parameter_map_t                         f_parameters;
    QString                                 f_cassandra_host;
    controlled_vars::zint32_t               f_cassandra_port;

    controlled_vars::zuint64_t              f_connections_count;
    snap_child_vector_t                     f_children_running;
    snap_child_vector_t                     f_children_waiting;

    getopt_ptr_t                            f_opt;

    std::auto_ptr<snap_listen_thread>       f_listen_runner;
    std::auto_ptr<snap_thread>              f_listen_thread;
};

} // namespace snap
// vim: ts=4 sw=4 et
