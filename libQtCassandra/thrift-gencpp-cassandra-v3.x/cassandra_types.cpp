/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "cassandra_types.h"

#include <algorithm>

namespace org { namespace apache { namespace cassandra {

int _kConsistencyLevelValues[] = {
  ConsistencyLevel::ONE,
  ConsistencyLevel::QUORUM,
  ConsistencyLevel::LOCAL_QUORUM,
  ConsistencyLevel::EACH_QUORUM,
  ConsistencyLevel::ALL,
  ConsistencyLevel::ANY,
  ConsistencyLevel::TWO,
  ConsistencyLevel::THREE,
  ConsistencyLevel::SERIAL,
  ConsistencyLevel::LOCAL_SERIAL,
  ConsistencyLevel::LOCAL_ONE
};
const char* _kConsistencyLevelNames[] = {
  "ONE",
  "QUORUM",
  "LOCAL_QUORUM",
  "EACH_QUORUM",
  "ALL",
  "ANY",
  "TWO",
  "THREE",
  "SERIAL",
  "LOCAL_SERIAL",
  "LOCAL_ONE"
};
const std::map<int, const char*> _ConsistencyLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kConsistencyLevelValues, _kConsistencyLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIndexOperatorValues[] = {
  IndexOperator::EQ,
  IndexOperator::GTE,
  IndexOperator::GT,
  IndexOperator::LTE,
  IndexOperator::LT
};
const char* _kIndexOperatorNames[] = {
  "EQ",
  "GTE",
  "GT",
  "LTE",
  "LT"
};
const std::map<int, const char*> _IndexOperator_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kIndexOperatorValues, _kIndexOperatorNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIndexTypeValues[] = {
  IndexType::KEYS,
  IndexType::CUSTOM,
  IndexType::COMPOSITES
};
const char* _kIndexTypeNames[] = {
  "KEYS",
  "CUSTOM",
  "COMPOSITES"
};
const std::map<int, const char*> _IndexType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kIndexTypeValues, _kIndexTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompressionValues[] = {
  Compression::GZIP,
  Compression::NONE
};
const char* _kCompressionNames[] = {
  "GZIP",
  "NONE"
};
const std::map<int, const char*> _Compression_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCompressionValues, _kCompressionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCqlResultTypeValues[] = {
  CqlResultType::ROWS,
  CqlResultType::VOID,
  CqlResultType::INT
};
const char* _kCqlResultTypeNames[] = {
  "ROWS",
  "VOID",
  "INT"
};
const std::map<int, const char*> _CqlResultType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCqlResultTypeValues, _kCqlResultTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Column::ascii_fingerprint = "3EE0E1C5C844001B62F08125068292CC";
const uint8_t Column::binary_fingerprint[16] = {0x3E,0xE0,0xE1,0xC5,0xC8,0x44,0x00,0x1B,0x62,0xF0,0x81,0x25,0x06,0x82,0x92,0xCC};

uint32_t Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Column");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttl) {
    xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->ttl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Column &a, Column &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.ttl, b.ttl);
  swap(a.__isset, b.__isset);
}

const char* SuperColumn::ascii_fingerprint = "470EFC558004E98D92D604898305C04E";
const uint8_t SuperColumn::binary_fingerprint[16] = {0x47,0x0E,0xFC,0x55,0x80,0x04,0xE9,0x8D,0x92,0xD6,0x04,0x89,0x83,0x05,0xC0,0x4E};

uint32_t SuperColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->columns.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->columns[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SuperColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SuperColumn");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<Column> ::const_iterator _iter5;
    for (_iter5 = this->columns.begin(); _iter5 != this->columns.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SuperColumn &a, SuperColumn &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.columns, b.columns);
}

const char* CounterColumn::ascii_fingerprint = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
const uint8_t CounterColumn::binary_fingerprint[16] = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

uint32_t CounterColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CounterColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CounterColumn");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CounterColumn &a, CounterColumn &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

const char* CounterSuperColumn::ascii_fingerprint = "CD4C8C4BF7753E46DE417CDE369343A4";
const uint8_t CounterSuperColumn::binary_fingerprint[16] = {0xCD,0x4C,0x8C,0x4B,0xF7,0x75,0x3E,0x46,0xDE,0x41,0x7C,0xDE,0x36,0x93,0x43,0xA4};

uint32_t CounterSuperColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->columns.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->columns[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CounterSuperColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CounterSuperColumn");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<CounterColumn> ::const_iterator _iter11;
    for (_iter11 = this->columns.begin(); _iter11 != this->columns.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CounterSuperColumn &a, CounterSuperColumn &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.columns, b.columns);
}

const char* ColumnOrSuperColumn::ascii_fingerprint = "2B34AC9E80F1DAA3A2A63B1AB1841E61";
const uint8_t ColumnOrSuperColumn::binary_fingerprint[16] = {0x2B,0x34,0xAC,0x9E,0x80,0xF1,0xDA,0xA3,0xA2,0xA6,0x3B,0x1A,0xB1,0x84,0x1E,0x61};

uint32_t ColumnOrSuperColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column.read(iprot);
          this->__isset.column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->super_column.read(iprot);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->counter_column.read(iprot);
          this->__isset.counter_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->counter_super_column.read(iprot);
          this->__isset.counter_super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnOrSuperColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnOrSuperColumn");

  if (this->__isset.column) {
    xfer += oprot->writeFieldBegin("column", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->super_column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counter_column) {
    xfer += oprot->writeFieldBegin("counter_column", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->counter_column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counter_super_column) {
    xfer += oprot->writeFieldBegin("counter_super_column", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->counter_super_column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnOrSuperColumn &a, ColumnOrSuperColumn &b) {
  using ::std::swap;
  swap(a.column, b.column);
  swap(a.super_column, b.super_column);
  swap(a.counter_column, b.counter_column);
  swap(a.counter_super_column, b.counter_super_column);
  swap(a.__isset, b.__isset);
}

const char* NotFoundException::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t NotFoundException::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t NotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotFoundException &a, NotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* InvalidRequestException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t InvalidRequestException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t InvalidRequestException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidRequestException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("InvalidRequestException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidRequestException &a, InvalidRequestException &b) {
  using ::std::swap;
  swap(a.why, b.why);
}

const char* UnavailableException::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t UnavailableException::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t UnavailableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnavailableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnavailableException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnavailableException &a, UnavailableException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* TimedOutException::ascii_fingerprint = "BCB1048B25A23A1B64C41A185F5F94DF";
const uint8_t TimedOutException::binary_fingerprint[16] = {0xBC,0xB1,0x04,0x8B,0x25,0xA2,0x3A,0x1B,0x64,0xC4,0x1A,0x18,0x5F,0x5F,0x94,0xDF};

uint32_t TimedOutException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->acknowledged_by);
          this->__isset.acknowledged_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->acknowledged_by_batchlog);
          this->__isset.acknowledged_by_batchlog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->paxos_in_progress);
          this->__isset.paxos_in_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimedOutException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TimedOutException");

  if (this->__isset.acknowledged_by) {
    xfer += oprot->writeFieldBegin("acknowledged_by", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->acknowledged_by);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.acknowledged_by_batchlog) {
    xfer += oprot->writeFieldBegin("acknowledged_by_batchlog", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->acknowledged_by_batchlog);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.paxos_in_progress) {
    xfer += oprot->writeFieldBegin("paxos_in_progress", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->paxos_in_progress);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimedOutException &a, TimedOutException &b) {
  using ::std::swap;
  swap(a.acknowledged_by, b.acknowledged_by);
  swap(a.acknowledged_by_batchlog, b.acknowledged_by_batchlog);
  swap(a.paxos_in_progress, b.paxos_in_progress);
  swap(a.__isset, b.__isset);
}

const char* AuthenticationException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AuthenticationException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AuthenticationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthenticationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthenticationException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthenticationException &a, AuthenticationException &b) {
  using ::std::swap;
  swap(a.why, b.why);
}

const char* AuthorizationException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AuthorizationException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AuthorizationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthorizationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthorizationException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthorizationException &a, AuthorizationException &b) {
  using ::std::swap;
  swap(a.why, b.why);
}

const char* SchemaDisagreementException::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t SchemaDisagreementException::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t SchemaDisagreementException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaDisagreementException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SchemaDisagreementException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaDisagreementException &a, SchemaDisagreementException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* ColumnParent::ascii_fingerprint = "0A13AE61181713A4100DFFB3EC293822";
const uint8_t ColumnParent::binary_fingerprint[16] = {0x0A,0x13,0xAE,0x61,0x18,0x17,0x13,0xA4,0x10,0x0D,0xFF,0xB3,0xEC,0x29,0x38,0x22};

uint32_t ColumnParent::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          isset_column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->super_column);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnParent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnParent");

  xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->super_column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnParent &a, ColumnParent &b) {
  using ::std::swap;
  swap(a.column_family, b.column_family);
  swap(a.super_column, b.super_column);
  swap(a.__isset, b.__isset);
}

const char* ColumnPath::ascii_fingerprint = "606212895BCF63C757913CF35AEB3462";
const uint8_t ColumnPath::binary_fingerprint[16] = {0x60,0x62,0x12,0x89,0x5B,0xCF,0x63,0xC7,0x57,0x91,0x3C,0xF3,0x5A,0xEB,0x34,0x62};

uint32_t ColumnPath::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          isset_column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->super_column);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->column);
          this->__isset.column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnPath::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnPath");

  xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->super_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column) {
    xfer += oprot->writeFieldBegin("column", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnPath &a, ColumnPath &b) {
  using ::std::swap;
  swap(a.column_family, b.column_family);
  swap(a.super_column, b.super_column);
  swap(a.column, b.column);
  swap(a.__isset, b.__isset);
}

const char* SliceRange::ascii_fingerprint = "184D24C9A0B8D4415E234DB649CAE740";
const uint8_t SliceRange::binary_fingerprint[16] = {0x18,0x4D,0x24,0xC9,0xA0,0xB8,0xD4,0x41,0x5E,0x23,0x4D,0xB6,0x49,0xCA,0xE7,0x40};

uint32_t SliceRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_start = false;
  bool isset_finish = false;
  bool isset_reversed = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start);
          isset_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->finish);
          isset_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          isset_reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_start)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_finish)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reversed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SliceRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SliceRange");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->finish);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->reversed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SliceRange &a, SliceRange &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.reversed, b.reversed);
  swap(a.count, b.count);
}

const char* SlicePredicate::ascii_fingerprint = "F59D1D81C17DFFAF09988BF1C9CE5E27";
const uint8_t SlicePredicate::binary_fingerprint[16] = {0xF5,0x9D,0x1D,0x81,0xC1,0x7D,0xFF,0xAF,0x09,0x98,0x8B,0xF1,0xC9,0xCE,0x5E,0x27};

uint32_t SlicePredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_names.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->column_names.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readBinary(this->column_names[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slice_range.read(iprot);
          this->__isset.slice_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SlicePredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SlicePredicate");

  if (this->__isset.column_names) {
    xfer += oprot->writeFieldBegin("column_names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_names.size()));
      std::vector<std::string> ::const_iterator _iter17;
      for (_iter17 = this->column_names.begin(); _iter17 != this->column_names.end(); ++_iter17)
      {
        xfer += oprot->writeBinary((*_iter17));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slice_range) {
    xfer += oprot->writeFieldBegin("slice_range", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->slice_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SlicePredicate &a, SlicePredicate &b) {
  using ::std::swap;
  swap(a.column_names, b.column_names);
  swap(a.slice_range, b.slice_range);
  swap(a.__isset, b.__isset);
}

const char* IndexExpression::ascii_fingerprint = "D9F4CFE2F293A8B1052FD3031DD2C847";
const uint8_t IndexExpression::binary_fingerprint[16] = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

uint32_t IndexExpression::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_name = false;
  bool isset_op = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->op = (IndexOperator::type)ecast18;
          isset_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IndexExpression::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IndexExpression");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexExpression &a, IndexExpression &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.op, b.op);
  swap(a.value, b.value);
}

const char* IndexClause::ascii_fingerprint = "9B551B9AB86120B0EEA9005C77FD3C1F";
const uint8_t IndexClause::binary_fingerprint[16] = {0x9B,0x55,0x1B,0x9A,0xB8,0x61,0x20,0xB0,0xEE,0xA9,0x00,0x5C,0x77,0xFD,0x3C,0x1F};

uint32_t IndexClause::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_expressions = false;
  bool isset_start_key = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expressions.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->expressions.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->expressions[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_expressions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start_key);
          isset_start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_expressions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IndexClause::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IndexClause");

  xfer += oprot->writeFieldBegin("expressions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->expressions.size()));
    std::vector<IndexExpression> ::const_iterator _iter24;
    for (_iter24 = this->expressions.begin(); _iter24 != this->expressions.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->start_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexClause &a, IndexClause &b) {
  using ::std::swap;
  swap(a.expressions, b.expressions);
  swap(a.start_key, b.start_key);
  swap(a.count, b.count);
}

const char* KeyRange::ascii_fingerprint = "A6EC82FA0980B91C7C8EB013C61CA1B0";
const uint8_t KeyRange::binary_fingerprint[16] = {0xA6,0xEC,0x82,0xFA,0x09,0x80,0xB9,0x1C,0x7C,0x8E,0xB0,0x13,0xC6,0x1C,0xA1,0xB0};

uint32_t KeyRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start_key);
          this->__isset.start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->end_key);
          this->__isset.end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_token);
          this->__isset.start_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_token);
          this->__isset.end_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_filter.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->row_filter.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->row_filter[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyRange");

  if (this->__isset.start_key) {
    xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->start_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_key) {
    xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->end_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_token) {
    xfer += oprot->writeFieldBegin("start_token", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->start_token);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_token) {
    xfer += oprot->writeFieldBegin("end_token", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->end_token);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.row_filter) {
    xfer += oprot->writeFieldBegin("row_filter", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_filter.size()));
      std::vector<IndexExpression> ::const_iterator _iter30;
      for (_iter30 = this->row_filter.begin(); _iter30 != this->row_filter.end(); ++_iter30)
      {
        xfer += (*_iter30).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyRange &a, KeyRange &b) {
  using ::std::swap;
  swap(a.start_key, b.start_key);
  swap(a.end_key, b.end_key);
  swap(a.start_token, b.start_token);
  swap(a.end_token, b.end_token);
  swap(a.row_filter, b.row_filter);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

const char* KeySlice::ascii_fingerprint = "D1568675B0C135C909E3169B72A4DA3D";
const uint8_t KeySlice::binary_fingerprint[16] = {0xD1,0x56,0x86,0x75,0xB0,0xC1,0x35,0xC9,0x09,0xE3,0x16,0x9B,0x72,0xA4,0xDA,0x3D};

uint32_t KeySlice::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->columns.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->columns[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeySlice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeySlice");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<ColumnOrSuperColumn> ::const_iterator _iter36;
    for (_iter36 = this->columns.begin(); _iter36 != this->columns.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeySlice &a, KeySlice &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.columns, b.columns);
}

const char* KeyCount::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t KeyCount::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t KeyCount::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyCount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyCount");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyCount &a, KeyCount &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.count, b.count);
}

const char* Deletion::ascii_fingerprint = "40F33ECF1C932CA77C2414C4E6C60CBE";
const uint8_t Deletion::binary_fingerprint[16] = {0x40,0xF3,0x3E,0xCF,0x1C,0x93,0x2C,0xA7,0x7C,0x24,0x14,0xC4,0xE6,0xC6,0x0C,0xBE};

uint32_t Deletion::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->super_column);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->predicate.read(iprot);
          this->__isset.predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Deletion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Deletion");

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->super_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.predicate) {
    xfer += oprot->writeFieldBegin("predicate", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Deletion &a, Deletion &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.super_column, b.super_column);
  swap(a.predicate, b.predicate);
  swap(a.__isset, b.__isset);
}

const char* Mutation::ascii_fingerprint = "E8B65DF3979C6868F80DF81F8E769E63";
const uint8_t Mutation::binary_fingerprint[16] = {0xE8,0xB6,0x5D,0xF3,0x97,0x9C,0x68,0x68,0xF8,0x0D,0xF8,0x1F,0x8E,0x76,0x9E,0x63};

uint32_t Mutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_or_supercolumn.read(iprot);
          this->__isset.column_or_supercolumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deletion.read(iprot);
          this->__isset.deletion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Mutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Mutation");

  if (this->__isset.column_or_supercolumn) {
    xfer += oprot->writeFieldBegin("column_or_supercolumn", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->column_or_supercolumn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deletion) {
    xfer += oprot->writeFieldBegin("deletion", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->deletion.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Mutation &a, Mutation &b) {
  using ::std::swap;
  swap(a.column_or_supercolumn, b.column_or_supercolumn);
  swap(a.deletion, b.deletion);
  swap(a.__isset, b.__isset);
}

const char* EndpointDetails::ascii_fingerprint = "F4A50F0EC638C7F66026F9B6678FD89B";
const uint8_t EndpointDetails::binary_fingerprint[16] = {0xF4,0xA5,0x0F,0x0E,0xC6,0x38,0xC7,0xF6,0x60,0x26,0xF9,0xB6,0x67,0x8F,0xD8,0x9B};

uint32_t EndpointDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter);
          this->__isset.datacenter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rack);
          this->__isset.rack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EndpointDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EndpointDetails");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("datacenter", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->datacenter);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rack) {
    xfer += oprot->writeFieldBegin("rack", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->rack);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EndpointDetails &a, EndpointDetails &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.datacenter, b.datacenter);
  swap(a.rack, b.rack);
  swap(a.__isset, b.__isset);
}

const char* CASResult::ascii_fingerprint = "E89EE887E1C0328427E46E2DE2236FDA";
const uint8_t CASResult::binary_fingerprint[16] = {0xE8,0x9E,0xE8,0x87,0xE1,0xC0,0x32,0x84,0x27,0xE4,0x6E,0x2D,0xE2,0x23,0x6F,0xDA};

uint32_t CASResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_success = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          isset_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->current_values.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->current_values.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->current_values[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.current_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CASResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CASResult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.current_values) {
    xfer += oprot->writeFieldBegin("current_values", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->current_values.size()));
      std::vector<Column> ::const_iterator _iter42;
      for (_iter42 = this->current_values.begin(); _iter42 != this->current_values.end(); ++_iter42)
      {
        xfer += (*_iter42).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CASResult &a, CASResult &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.current_values, b.current_values);
  swap(a.__isset, b.__isset);
}

const char* TokenRange::ascii_fingerprint = "832268DC4CD6B17EE8881FC57EA04679";
const uint8_t TokenRange::binary_fingerprint[16] = {0x83,0x22,0x68,0xDC,0x4C,0xD6,0xB1,0x7E,0xE8,0x88,0x1F,0xC5,0x7E,0xA0,0x46,0x79};

uint32_t TokenRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_start_token = false;
  bool isset_end_token = false;
  bool isset_endpoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_token);
          isset_start_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_token);
          isset_end_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoints.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->endpoints.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readString(this->endpoints[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          isset_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rpc_endpoints.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->rpc_endpoints.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->rpc_endpoints[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rpc_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoint_details.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->endpoint_details.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += this->endpoint_details[_i57].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.endpoint_details = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_start_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endpoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TokenRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TokenRange");

  xfer += oprot->writeFieldBegin("start_token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endpoints", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->endpoints.size()));
    std::vector<std::string> ::const_iterator _iter58;
    for (_iter58 = this->endpoints.begin(); _iter58 != this->endpoints.end(); ++_iter58)
    {
      xfer += oprot->writeString((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rpc_endpoints) {
    xfer += oprot->writeFieldBegin("rpc_endpoints", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rpc_endpoints.size()));
      std::vector<std::string> ::const_iterator _iter59;
      for (_iter59 = this->rpc_endpoints.begin(); _iter59 != this->rpc_endpoints.end(); ++_iter59)
      {
        xfer += oprot->writeString((*_iter59));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endpoint_details) {
    xfer += oprot->writeFieldBegin("endpoint_details", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->endpoint_details.size()));
      std::vector<EndpointDetails> ::const_iterator _iter60;
      for (_iter60 = this->endpoint_details.begin(); _iter60 != this->endpoint_details.end(); ++_iter60)
      {
        xfer += (*_iter60).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenRange &a, TokenRange &b) {
  using ::std::swap;
  swap(a.start_token, b.start_token);
  swap(a.end_token, b.end_token);
  swap(a.endpoints, b.endpoints);
  swap(a.rpc_endpoints, b.rpc_endpoints);
  swap(a.endpoint_details, b.endpoint_details);
  swap(a.__isset, b.__isset);
}

const char* AuthenticationRequest::ascii_fingerprint = "5EA2D527ECA3BA20C77AFC023EE8C05F";
const uint8_t AuthenticationRequest::binary_fingerprint[16] = {0x5E,0xA2,0xD5,0x27,0xEC,0xA3,0xBA,0x20,0xC7,0x7A,0xFC,0x02,0x3E,0xE8,0xC0,0x5F};

uint32_t AuthenticationRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_credentials = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->credentials.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              std::string _key66;
              xfer += iprot->readString(_key66);
              std::string& _val67 = this->credentials[_key66];
              xfer += iprot->readString(_val67);
            }
            xfer += iprot->readMapEnd();
          }
          isset_credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_credentials)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthenticationRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthenticationRequest");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->credentials.size()));
    std::map<std::string, std::string> ::const_iterator _iter68;
    for (_iter68 = this->credentials.begin(); _iter68 != this->credentials.end(); ++_iter68)
    {
      xfer += oprot->writeString(_iter68->first);
      xfer += oprot->writeString(_iter68->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthenticationRequest &a, AuthenticationRequest &b) {
  using ::std::swap;
  swap(a.credentials, b.credentials);
}

const char* ColumnDef::ascii_fingerprint = "0D89CE83D7EDAD079AC3213ED1DCAA58";
const uint8_t ColumnDef::binary_fingerprint[16] = {0x0D,0x89,0xCE,0x83,0xD7,0xED,0xAD,0x07,0x9A,0xC3,0x21,0x3E,0xD1,0xDC,0xAA,0x58};

uint32_t ColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_validation_class = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validation_class);
          isset_validation_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->index_type = (IndexType::type)ecast69;
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->index_options.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _ktype71;
            ::apache::thrift::protocol::TType _vtype72;
            xfer += iprot->readMapBegin(_ktype71, _vtype72, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              std::string _key75;
              xfer += iprot->readString(_key75);
              std::string& _val76 = this->index_options[_key75];
              xfer += iprot->readString(_val76);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.index_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_validation_class)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validation_class", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->validation_class);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.index_type) {
    xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->index_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_name) {
    xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->index_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_options) {
    xfer += oprot->writeFieldBegin("index_options", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->index_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter77;
      for (_iter77 = this->index_options.begin(); _iter77 != this->index_options.end(); ++_iter77)
      {
        xfer += oprot->writeString(_iter77->first);
        xfer += oprot->writeString(_iter77->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnDef &a, ColumnDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.validation_class, b.validation_class);
  swap(a.index_type, b.index_type);
  swap(a.index_name, b.index_name);
  swap(a.index_options, b.index_options);
  swap(a.__isset, b.__isset);
}

const char* TriggerDef::ascii_fingerprint = "F7C641917C22B35AE581CCD54910B00D";
const uint8_t TriggerDef::binary_fingerprint[16] = {0xF7,0xC6,0x41,0x91,0x7C,0x22,0xB3,0x5A,0xE5,0x81,0xCC,0xD5,0x49,0x10,0xB0,0x0D};

uint32_t TriggerDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_options = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _ktype79;
            ::apache::thrift::protocol::TType _vtype80;
            xfer += iprot->readMapBegin(_ktype79, _vtype80, _size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              std::string _key83;
              xfer += iprot->readString(_key83);
              std::string& _val84 = this->options[_key83];
              xfer += iprot->readString(_val84);
            }
            xfer += iprot->readMapEnd();
          }
          isset_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TriggerDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TriggerDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::map<std::string, std::string> ::const_iterator _iter85;
    for (_iter85 = this->options.begin(); _iter85 != this->options.end(); ++_iter85)
    {
      xfer += oprot->writeString(_iter85->first);
      xfer += oprot->writeString(_iter85->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TriggerDef &a, TriggerDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.options, b.options);
}

const char* CfDef::ascii_fingerprint = "D885AE83382BA6B36ADA00E72F8B71C3";
const uint8_t CfDef::binary_fingerprint[16] = {0xD8,0x85,0xAE,0x83,0x38,0x2B,0xA6,0xB3,0x6A,0xDA,0x00,0xE7,0x2F,0x8B,0x71,0xC3};

uint32_t CfDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keyspace = false;
  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->keyspace);
          isset_keyspace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_type);
          this->__isset.column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comparator_type);
          this->__isset.comparator_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subcomparator_type);
          this->__isset.subcomparator_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->read_repair_chance);
          this->__isset.read_repair_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_metadata.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->column_metadata.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += this->column_metadata[_i90].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gc_grace_seconds);
          this->__isset.gc_grace_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_validation_class);
          this->__isset.default_validation_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_compaction_threshold);
          this->__isset.min_compaction_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_compaction_threshold);
          this->__isset.max_compaction_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_validation_class);
          this->__isset.key_validation_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key_alias);
          this->__isset.key_alias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->compaction_strategy);
          this->__isset.compaction_strategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->compaction_strategy_options.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _ktype92;
            ::apache::thrift::protocol::TType _vtype93;
            xfer += iprot->readMapBegin(_ktype92, _vtype93, _size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              std::string _key96;
              xfer += iprot->readString(_key96);
              std::string& _val97 = this->compaction_strategy_options[_key96];
              xfer += iprot->readString(_val97);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.compaction_strategy_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->compression_options.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _ktype99;
            ::apache::thrift::protocol::TType _vtype100;
            xfer += iprot->readMapBegin(_ktype99, _vtype100, _size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              std::string _key103;
              xfer += iprot->readString(_key103);
              std::string& _val104 = this->compression_options[_key103];
              xfer += iprot->readString(_val104);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.compression_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bloom_filter_fp_chance);
          this->__isset.bloom_filter_fp_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dclocal_read_repair_chance);
          this->__isset.dclocal_read_repair_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memtable_flush_period_in_ms);
          this->__isset.memtable_flush_period_in_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->default_time_to_live);
          this->__isset.default_time_to_live = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->speculative_retry);
          this->__isset.speculative_retry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->triggers.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += this->triggers[_i109].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cells_per_row_to_cache);
          this->__isset.cells_per_row_to_cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_index_interval);
          this->__isset.min_index_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 46:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_index_interval);
          this->__isset.max_index_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->row_cache_size);
          this->__isset.row_cache_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->key_cache_size);
          this->__isset.key_cache_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_cache_save_period_in_seconds);
          this->__isset.row_cache_save_period_in_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_cache_save_period_in_seconds);
          this->__isset.key_cache_save_period_in_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memtable_flush_after_mins);
          this->__isset.memtable_flush_after_mins = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memtable_throughput_in_mb);
          this->__isset.memtable_throughput_in_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->memtable_operations_in_millions);
          this->__isset.memtable_operations_in_millions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replicate_on_write);
          this->__isset.replicate_on_write = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->merge_shards_chance);
          this->__isset.merge_shards_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row_cache_provider);
          this->__isset.row_cache_provider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_cache_keys_to_save);
          this->__isset.row_cache_keys_to_save = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->populate_io_cache_on_flush);
          this->__isset.populate_io_cache_on_flush = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index_interval);
          this->__isset.index_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keyspace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CfDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CfDef");

  xfer += oprot->writeFieldBegin("keyspace", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->keyspace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.column_type) {
    xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->column_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comparator_type) {
    xfer += oprot->writeFieldBegin("comparator_type", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->comparator_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subcomparator_type) {
    xfer += oprot->writeFieldBegin("subcomparator_type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->subcomparator_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_size) {
    xfer += oprot->writeFieldBegin("row_cache_size", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->row_cache_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_cache_size) {
    xfer += oprot->writeFieldBegin("key_cache_size", ::apache::thrift::protocol::T_DOUBLE, 11);
    xfer += oprot->writeDouble(this->key_cache_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.read_repair_chance) {
    xfer += oprot->writeFieldBegin("read_repair_chance", ::apache::thrift::protocol::T_DOUBLE, 12);
    xfer += oprot->writeDouble(this->read_repair_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_metadata) {
    xfer += oprot->writeFieldBegin("column_metadata", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_metadata.size()));
      std::vector<ColumnDef> ::const_iterator _iter110;
      for (_iter110 = this->column_metadata.begin(); _iter110 != this->column_metadata.end(); ++_iter110)
      {
        xfer += (*_iter110).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gc_grace_seconds) {
    xfer += oprot->writeFieldBegin("gc_grace_seconds", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->gc_grace_seconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_validation_class) {
    xfer += oprot->writeFieldBegin("default_validation_class", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->default_validation_class);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_compaction_threshold) {
    xfer += oprot->writeFieldBegin("min_compaction_threshold", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32(this->min_compaction_threshold);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_compaction_threshold) {
    xfer += oprot->writeFieldBegin("max_compaction_threshold", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->max_compaction_threshold);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_save_period_in_seconds) {
    xfer += oprot->writeFieldBegin("row_cache_save_period_in_seconds", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->row_cache_save_period_in_seconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_cache_save_period_in_seconds) {
    xfer += oprot->writeFieldBegin("key_cache_save_period_in_seconds", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32(this->key_cache_save_period_in_seconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_flush_after_mins) {
    xfer += oprot->writeFieldBegin("memtable_flush_after_mins", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32(this->memtable_flush_after_mins);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_throughput_in_mb) {
    xfer += oprot->writeFieldBegin("memtable_throughput_in_mb", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->memtable_throughput_in_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_operations_in_millions) {
    xfer += oprot->writeFieldBegin("memtable_operations_in_millions", ::apache::thrift::protocol::T_DOUBLE, 23);
    xfer += oprot->writeDouble(this->memtable_operations_in_millions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicate_on_write) {
    xfer += oprot->writeFieldBegin("replicate_on_write", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->replicate_on_write);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_shards_chance) {
    xfer += oprot->writeFieldBegin("merge_shards_chance", ::apache::thrift::protocol::T_DOUBLE, 25);
    xfer += oprot->writeDouble(this->merge_shards_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_validation_class) {
    xfer += oprot->writeFieldBegin("key_validation_class", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->key_validation_class);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_provider) {
    xfer += oprot->writeFieldBegin("row_cache_provider", ::apache::thrift::protocol::T_STRING, 27);
    xfer += oprot->writeString(this->row_cache_provider);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_alias) {
    xfer += oprot->writeFieldBegin("key_alias", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeBinary(this->key_alias);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compaction_strategy) {
    xfer += oprot->writeFieldBegin("compaction_strategy", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->compaction_strategy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compaction_strategy_options) {
    xfer += oprot->writeFieldBegin("compaction_strategy_options", ::apache::thrift::protocol::T_MAP, 30);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->compaction_strategy_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter111;
      for (_iter111 = this->compaction_strategy_options.begin(); _iter111 != this->compaction_strategy_options.end(); ++_iter111)
      {
        xfer += oprot->writeString(_iter111->first);
        xfer += oprot->writeString(_iter111->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_keys_to_save) {
    xfer += oprot->writeFieldBegin("row_cache_keys_to_save", ::apache::thrift::protocol::T_I32, 31);
    xfer += oprot->writeI32(this->row_cache_keys_to_save);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compression_options) {
    xfer += oprot->writeFieldBegin("compression_options", ::apache::thrift::protocol::T_MAP, 32);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->compression_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter112;
      for (_iter112 = this->compression_options.begin(); _iter112 != this->compression_options.end(); ++_iter112)
      {
        xfer += oprot->writeString(_iter112->first);
        xfer += oprot->writeString(_iter112->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloom_filter_fp_chance) {
    xfer += oprot->writeFieldBegin("bloom_filter_fp_chance", ::apache::thrift::protocol::T_DOUBLE, 33);
    xfer += oprot->writeDouble(this->bloom_filter_fp_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_STRING, 34);
    xfer += oprot->writeString(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dclocal_read_repair_chance) {
    xfer += oprot->writeFieldBegin("dclocal_read_repair_chance", ::apache::thrift::protocol::T_DOUBLE, 37);
    xfer += oprot->writeDouble(this->dclocal_read_repair_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.populate_io_cache_on_flush) {
    xfer += oprot->writeFieldBegin("populate_io_cache_on_flush", ::apache::thrift::protocol::T_BOOL, 38);
    xfer += oprot->writeBool(this->populate_io_cache_on_flush);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_flush_period_in_ms) {
    xfer += oprot->writeFieldBegin("memtable_flush_period_in_ms", ::apache::thrift::protocol::T_I32, 39);
    xfer += oprot->writeI32(this->memtable_flush_period_in_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_time_to_live) {
    xfer += oprot->writeFieldBegin("default_time_to_live", ::apache::thrift::protocol::T_I32, 40);
    xfer += oprot->writeI32(this->default_time_to_live);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_interval) {
    xfer += oprot->writeFieldBegin("index_interval", ::apache::thrift::protocol::T_I32, 41);
    xfer += oprot->writeI32(this->index_interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.speculative_retry) {
    xfer += oprot->writeFieldBegin("speculative_retry", ::apache::thrift::protocol::T_STRING, 42);
    xfer += oprot->writeString(this->speculative_retry);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 43);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<TriggerDef> ::const_iterator _iter113;
      for (_iter113 = this->triggers.begin(); _iter113 != this->triggers.end(); ++_iter113)
      {
        xfer += (*_iter113).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells_per_row_to_cache) {
    xfer += oprot->writeFieldBegin("cells_per_row_to_cache", ::apache::thrift::protocol::T_STRING, 44);
    xfer += oprot->writeString(this->cells_per_row_to_cache);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_index_interval) {
    xfer += oprot->writeFieldBegin("min_index_interval", ::apache::thrift::protocol::T_I32, 45);
    xfer += oprot->writeI32(this->min_index_interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_index_interval) {
    xfer += oprot->writeFieldBegin("max_index_interval", ::apache::thrift::protocol::T_I32, 46);
    xfer += oprot->writeI32(this->max_index_interval);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CfDef &a, CfDef &b) {
  using ::std::swap;
  swap(a.keyspace, b.keyspace);
  swap(a.name, b.name);
  swap(a.column_type, b.column_type);
  swap(a.comparator_type, b.comparator_type);
  swap(a.subcomparator_type, b.subcomparator_type);
  swap(a.comment, b.comment);
  swap(a.read_repair_chance, b.read_repair_chance);
  swap(a.column_metadata, b.column_metadata);
  swap(a.gc_grace_seconds, b.gc_grace_seconds);
  swap(a.default_validation_class, b.default_validation_class);
  swap(a.id, b.id);
  swap(a.min_compaction_threshold, b.min_compaction_threshold);
  swap(a.max_compaction_threshold, b.max_compaction_threshold);
  swap(a.key_validation_class, b.key_validation_class);
  swap(a.key_alias, b.key_alias);
  swap(a.compaction_strategy, b.compaction_strategy);
  swap(a.compaction_strategy_options, b.compaction_strategy_options);
  swap(a.compression_options, b.compression_options);
  swap(a.bloom_filter_fp_chance, b.bloom_filter_fp_chance);
  swap(a.caching, b.caching);
  swap(a.dclocal_read_repair_chance, b.dclocal_read_repair_chance);
  swap(a.memtable_flush_period_in_ms, b.memtable_flush_period_in_ms);
  swap(a.default_time_to_live, b.default_time_to_live);
  swap(a.speculative_retry, b.speculative_retry);
  swap(a.triggers, b.triggers);
  swap(a.cells_per_row_to_cache, b.cells_per_row_to_cache);
  swap(a.min_index_interval, b.min_index_interval);
  swap(a.max_index_interval, b.max_index_interval);
  swap(a.row_cache_size, b.row_cache_size);
  swap(a.key_cache_size, b.key_cache_size);
  swap(a.row_cache_save_period_in_seconds, b.row_cache_save_period_in_seconds);
  swap(a.key_cache_save_period_in_seconds, b.key_cache_save_period_in_seconds);
  swap(a.memtable_flush_after_mins, b.memtable_flush_after_mins);
  swap(a.memtable_throughput_in_mb, b.memtable_throughput_in_mb);
  swap(a.memtable_operations_in_millions, b.memtable_operations_in_millions);
  swap(a.replicate_on_write, b.replicate_on_write);
  swap(a.merge_shards_chance, b.merge_shards_chance);
  swap(a.row_cache_provider, b.row_cache_provider);
  swap(a.row_cache_keys_to_save, b.row_cache_keys_to_save);
  swap(a.populate_io_cache_on_flush, b.populate_io_cache_on_flush);
  swap(a.index_interval, b.index_interval);
  swap(a.__isset, b.__isset);
}

const char* KsDef::ascii_fingerprint = "7D6A6369147C130D38028C620FFF44A2";
const uint8_t KsDef::binary_fingerprint[16] = {0x7D,0x6A,0x63,0x69,0x14,0x7C,0x13,0x0D,0x38,0x02,0x8C,0x62,0x0F,0xFF,0x44,0xA2};

uint32_t KsDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_strategy_class = false;
  bool isset_cf_defs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strategy_class);
          isset_strategy_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->strategy_options.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _ktype115;
            ::apache::thrift::protocol::TType _vtype116;
            xfer += iprot->readMapBegin(_ktype115, _vtype116, _size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              std::string _key119;
              xfer += iprot->readString(_key119);
              std::string& _val120 = this->strategy_options[_key119];
              xfer += iprot->readString(_val120);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.strategy_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replication_factor);
          this->__isset.replication_factor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cf_defs.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->cf_defs.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += this->cf_defs[_i125].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cf_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->durable_writes);
          this->__isset.durable_writes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_strategy_class)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cf_defs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KsDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KsDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strategy_class", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->strategy_class);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.strategy_options) {
    xfer += oprot->writeFieldBegin("strategy_options", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strategy_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter126;
      for (_iter126 = this->strategy_options.begin(); _iter126 != this->strategy_options.end(); ++_iter126)
      {
        xfer += oprot->writeString(_iter126->first);
        xfer += oprot->writeString(_iter126->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replication_factor) {
    xfer += oprot->writeFieldBegin("replication_factor", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->replication_factor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("cf_defs", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cf_defs.size()));
    std::vector<CfDef> ::const_iterator _iter127;
    for (_iter127 = this->cf_defs.begin(); _iter127 != this->cf_defs.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.durable_writes) {
    xfer += oprot->writeFieldBegin("durable_writes", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->durable_writes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KsDef &a, KsDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.strategy_class, b.strategy_class);
  swap(a.strategy_options, b.strategy_options);
  swap(a.replication_factor, b.replication_factor);
  swap(a.cf_defs, b.cf_defs);
  swap(a.durable_writes, b.durable_writes);
  swap(a.__isset, b.__isset);
}

const char* CqlRow::ascii_fingerprint = "470EFC558004E98D92D604898305C04E";
const uint8_t CqlRow::binary_fingerprint[16] = {0x47,0x0E,0xFC,0x55,0x80,0x04,0xE9,0x8D,0x92,0xD6,0x04,0x89,0x83,0x05,0xC0,0x4E};

uint32_t CqlRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size128;
            ::apache::thrift::protocol::TType _etype131;
            xfer += iprot->readListBegin(_etype131, _size128);
            this->columns.resize(_size128);
            uint32_t _i132;
            for (_i132 = 0; _i132 < _size128; ++_i132)
            {
              xfer += this->columns[_i132].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlRow");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<Column> ::const_iterator _iter133;
    for (_iter133 = this->columns.begin(); _iter133 != this->columns.end(); ++_iter133)
    {
      xfer += (*_iter133).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlRow &a, CqlRow &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.columns, b.columns);
}

const char* CqlMetadata::ascii_fingerprint = "B7C5A4AA9652C744A48EBC1C12D531E7";
const uint8_t CqlMetadata::binary_fingerprint[16] = {0xB7,0xC5,0xA4,0xAA,0x96,0x52,0xC7,0x44,0xA4,0x8E,0xBC,0x1C,0x12,0xD5,0x31,0xE7};

uint32_t CqlMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name_types = false;
  bool isset_value_types = false;
  bool isset_default_name_type = false;
  bool isset_default_value_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->name_types.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _ktype135;
            ::apache::thrift::protocol::TType _vtype136;
            xfer += iprot->readMapBegin(_ktype135, _vtype136, _size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              std::string _key139;
              xfer += iprot->readBinary(_key139);
              std::string& _val140 = this->name_types[_key139];
              xfer += iprot->readString(_val140);
            }
            xfer += iprot->readMapEnd();
          }
          isset_name_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->value_types.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _ktype142;
            ::apache::thrift::protocol::TType _vtype143;
            xfer += iprot->readMapBegin(_ktype142, _vtype143, _size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              std::string _key146;
              xfer += iprot->readBinary(_key146);
              std::string& _val147 = this->value_types[_key146];
              xfer += iprot->readString(_val147);
            }
            xfer += iprot->readMapEnd();
          }
          isset_value_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_name_type);
          isset_default_name_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value_type);
          isset_default_value_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_default_name_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_default_value_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlMetadata");

  xfer += oprot->writeFieldBegin("name_types", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->name_types.size()));
    std::map<std::string, std::string> ::const_iterator _iter148;
    for (_iter148 = this->name_types.begin(); _iter148 != this->name_types.end(); ++_iter148)
    {
      xfer += oprot->writeBinary(_iter148->first);
      xfer += oprot->writeString(_iter148->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value_types", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->value_types.size()));
    std::map<std::string, std::string> ::const_iterator _iter149;
    for (_iter149 = this->value_types.begin(); _iter149 != this->value_types.end(); ++_iter149)
    {
      xfer += oprot->writeBinary(_iter149->first);
      xfer += oprot->writeString(_iter149->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_name_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->default_name_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_value_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->default_value_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlMetadata &a, CqlMetadata &b) {
  using ::std::swap;
  swap(a.name_types, b.name_types);
  swap(a.value_types, b.value_types);
  swap(a.default_name_type, b.default_name_type);
  swap(a.default_value_type, b.default_value_type);
}

const char* CqlResult::ascii_fingerprint = "521B9CE5AF77539F7267F6952B609E81";
const uint8_t CqlResult::binary_fingerprint[16] = {0x52,0x1B,0x9C,0xE5,0xAF,0x77,0x53,0x9F,0x72,0x67,0xF6,0x95,0x2B,0x60,0x9E,0x81};

uint32_t CqlResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast150;
          xfer += iprot->readI32(ecast150);
          this->type = (CqlResultType::type)ecast150;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->rows.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += this->rows[_i155].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlResult");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rows) {
    xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
      std::vector<CqlRow> ::const_iterator _iter156;
      for (_iter156 = this->rows.begin(); _iter156 != this->rows.end(); ++_iter156)
      {
        xfer += (*_iter156).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num) {
    xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schema) {
    xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->schema.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlResult &a, CqlResult &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.rows, b.rows);
  swap(a.num, b.num);
  swap(a.schema, b.schema);
  swap(a.__isset, b.__isset);
}

const char* CqlPreparedResult::ascii_fingerprint = "7E1663EC688DFDC28722BF36F9F64E6F";
const uint8_t CqlPreparedResult::binary_fingerprint[16] = {0x7E,0x16,0x63,0xEC,0x68,0x8D,0xFD,0xC2,0x87,0x22,0xBF,0x36,0xF9,0xF6,0x4E,0x6F};

uint32_t CqlPreparedResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_itemId = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemId);
          isset_itemId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->variable_types.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            this->variable_types.resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += iprot->readString(this->variable_types[_i161]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.variable_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->variable_names.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->variable_names.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += iprot->readString(this->variable_names[_i166]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.variable_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_itemId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlPreparedResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlPreparedResult");

  xfer += oprot->writeFieldBegin("itemId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->itemId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.variable_types) {
    xfer += oprot->writeFieldBegin("variable_types", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->variable_types.size()));
      std::vector<std::string> ::const_iterator _iter167;
      for (_iter167 = this->variable_types.begin(); _iter167 != this->variable_types.end(); ++_iter167)
      {
        xfer += oprot->writeString((*_iter167));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variable_names) {
    xfer += oprot->writeFieldBegin("variable_names", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->variable_names.size()));
      std::vector<std::string> ::const_iterator _iter168;
      for (_iter168 = this->variable_names.begin(); _iter168 != this->variable_names.end(); ++_iter168)
      {
        xfer += oprot->writeString((*_iter168));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlPreparedResult &a, CqlPreparedResult &b) {
  using ::std::swap;
  swap(a.itemId, b.itemId);
  swap(a.count, b.count);
  swap(a.variable_types, b.variable_types);
  swap(a.variable_names, b.variable_names);
  swap(a.__isset, b.__isset);
}

const char* CfSplit::ascii_fingerprint = "A0ED90CE9B69D7A0FCE24E26CAECD2AF";
const uint8_t CfSplit::binary_fingerprint[16] = {0xA0,0xED,0x90,0xCE,0x9B,0x69,0xD7,0xA0,0xFC,0xE2,0x4E,0x26,0xCA,0xEC,0xD2,0xAF};

uint32_t CfSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_start_token = false;
  bool isset_end_token = false;
  bool isset_row_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_token);
          isset_start_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_token);
          isset_end_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_count);
          isset_row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_start_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CfSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CfSplit");

  xfer += oprot->writeFieldBegin("start_token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_count", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->row_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CfSplit &a, CfSplit &b) {
  using ::std::swap;
  swap(a.start_token, b.start_token);
  swap(a.end_token, b.end_token);
  swap(a.row_count, b.row_count);
}

const char* ColumnSlice::ascii_fingerprint = "D0297FC5011701BD87898CC36146A565";
const uint8_t ColumnSlice::binary_fingerprint[16] = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

uint32_t ColumnSlice::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->finish);
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnSlice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnSlice");

  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finish) {
    xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->finish);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnSlice &a, ColumnSlice &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.__isset, b.__isset);
}

const char* MultiSliceRequest::ascii_fingerprint = "65D4C6578392956433677091AF9D8B67";
const uint8_t MultiSliceRequest::binary_fingerprint[16] = {0x65,0xD4,0xC6,0x57,0x83,0x92,0x95,0x64,0x33,0x67,0x70,0x91,0xAF,0x9D,0x8B,0x67};

uint32_t MultiSliceRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_parent.read(iprot);
          this->__isset.column_parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_slices.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->column_slices.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += this->column_slices[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_slices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          this->__isset.reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast174;
          xfer += iprot->readI32(ecast174);
          this->consistency_level = (ConsistencyLevel::type)ecast174;
          this->__isset.consistency_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MultiSliceRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MultiSliceRequest");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_parent) {
    xfer += oprot->writeFieldBegin("column_parent", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->column_parent.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_slices) {
    xfer += oprot->writeFieldBegin("column_slices", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_slices.size()));
      std::vector<ColumnSlice> ::const_iterator _iter175;
      for (_iter175 = this->column_slices.begin(); _iter175 != this->column_slices.end(); ++_iter175)
      {
        xfer += (*_iter175).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reversed) {
    xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->reversed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.count) {
    xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consistency_level) {
    xfer += oprot->writeFieldBegin("consistency_level", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->consistency_level);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MultiSliceRequest &a, MultiSliceRequest &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.column_parent, b.column_parent);
  swap(a.column_slices, b.column_slices);
  swap(a.reversed, b.reversed);
  swap(a.count, b.count);
  swap(a.consistency_level, b.consistency_level);
  swap(a.__isset, b.__isset);
}

}}} // namespace
