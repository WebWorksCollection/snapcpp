
To be closer to what SASS supports, we shall implement the following
additional features:

. variable named when calling a function (to allow any order):

     $func($name: value, $arg2: value2, ...)


. Implement @extend


. Support the placeholder in the assembler


. Support for lists / maps in expressions


. Full coverage for expressions, also look into adding many still missing
  operations (i.e. color + color, color * 3, int * flt, etc.)


. Add !important in variables, preventing further definitions of that variable

      $var-final: 3px !important;

      $var-final: 15px;  <-- error, !important prevents redefinition


. Add code to check all selectors (that way we can err on a syntax error):

      @selectors {
        @extends; [or] @override; -- whether we reset the system lists or not
        tags: html div p span ...;
        invalid-tags: title link script iframe ...;
        classes: .wrapper .menu-item ...;
        identifiers: #content #menu ...;
        attributes: href enabled class ...;
        attribute-values: ???; -- would we really want to support that one?!
      }

. Add proper support for -moz-, -ms-, etc. with selector (pseudo-classes, etc.)

    At this point I am thinking that a good way could be to test
    a first time with the name as is and if the name starts with -<name>-
    (where <name> is a known browser "name") then we try again without
    the -<name>-. This gives us a way to allow extensions that do not
    otherwise have a standard equivalent.

    A similar method will be required to check field names.

    Also, I added some "inline compiler validation" that checks things like
    an asterisk before a field name (*border: 1px; for IE5-IE7) and a few
    other IE special features (many filters, expression() and probably more
    as time passes.)

. Validations generate errors printing out their own position, we would
  need to show the position in the user source, not the validation SCSS file.


vim: tw=2 sw=2 et
