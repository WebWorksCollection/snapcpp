
# Note: in many cases a filename can be "." (current directory)

# Create a new private repository
# The following tells me the steps of creating a new private repository
# as we do not have a way that automates that 100%
#
#  1. create your own local repository
git init
git add "<your-file(s)>"
git commit

#  2. create the remote repository
ssh build.m2osw.com
sudo su - git
cd /mnt/git
mkdir "<your-repository-name>"
cd "<your-repository-name>"
git init --bare

#  3. make the new remote repository your URL in your local repository
git remote add origin "ssh://buildgit/mnt/git/<your-repository-name>"
git push -u origin master

# if you already added a URL, then you will need to use the "set-url"
# instead of the "add" instruction:
git remote set-url origin "ssh://buildgit/mnt/git/<your-repository-name>"

#  4. verify status
prompt $ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean




# Check out a copy from the repository
#git clone git://git.code.sf.net/p/snapcpp/code snapcpp -- very old, not up to date
git clone --recursive git@github.com:m2osw/snapcpp

# check what you've changed (verify that you want to commit all of those)
git diff ["<filename>"]

# check files that have changed, the status
git status ["<filename>"]

# -a == all
git commit -m 'info about commit' -a
git commit -m 'info about commit' "<filename>"

# retrieve data from repository (changes by others)
git pull origin master

# push your changes to the server (you may need a pull first)
git push origin master

# fix a conflict
# After a git pull ... you may have a conflict (you should see that in the
# output of git); first edit the file and search for <<<, >>>, or === and
# correct the code as required; then do a commit on that filename, after
# that you should be all fine.
git commit -i "<filename>"


# amend a commit
# It is not actually possible to update a commit in place. Instead you
# create an amendment which you can hope will be used as expected.
# To amend you last commit, just use --amend
git commit --amend

# If you want to amend an older commit, use -c <id> which you get with
# a git log (see the long SHA number after the word commit)
git commit --amend -c 123...123

# Amending also involves merging, somehow.
# For additional information about amending and fixing comments in your
# commits, there is a great page about that here:
# https://help.github.com/articles/changing-a-commit-message/


# changing the URL of the origin
git remote set-url origin git@github.com:m2osw/snapcpp.git


# watchout with the --hard option! It is useful to reset all the files
# from a "bad" checkout (i.e. from a different branch for example)
git reset --hard HEAD

# Remove one or more files from your last commit (assuming you did not push yet)
git reset --soft HEAD^
git reset HEAD path/to/unwanted_file
#...repeat previous command for each file to be removed from the last commit...
git commit -c ORIG_HEAD

# Remove a commit that was pushed requires the revert command instead
git revert 123                 # use git log to get the commit-id


# Find list of files in a git commit
git log --stat ["path"]


# Handling branches
#
# More details available on this page (and next/previous)
#    https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging
#
# WARNING: By default, switching from the master to another branch
#          forces a merge (I do not understand why that would be a good
#          thing though.)
#
# In your home directory, edit .gitconfig and plaster:
#
#    [branch]
#        autosetupmerge = always
#        autosetuprebase = always
#
git branch "branch-name"       # creates a new branch
git checkout "branch-name"     # switch between branches
git checkout -b "branch-name" [--track origin/branch-name]   # create the branch from remote and switch to it
git merge "branch-name"        # merge <name> in current branch
git branch -d "branch-name"    # delete a branch
git fetch                      # fetch all (including remote) branches
git diff "branch-nameA" "branch-nameB" -- "filename"   # diff "filename" between two branches

# If you already have changes that you want to save in a different branch:
git branch "branch-name"
git checkout "branch-name"
git commit "branch-name"


# Merging one commit in another branch
#
# Say you create a cool commit in master and want to add that to a certain
# branch, maybe because that other branch is a release branch and you only
# want to fix one small thing in that branch... That's done with cherry-pick
# but if you have auto-rebase like me, then you need to abort the rebasing
# in case you get a conflict.
#
# Because you are breaking the nice tree (i.e. not taking each commit in
# between on either side) you also have to --force the push.
#
# If you miss a step and seemingly have a problem, try "git rebase --skip"
# to restore the files you cherry picked.
git pull origin "branch-name"
git cherry-pick "commit-id"
...edit conflicts...
git add "path/to/file/with/conflicts"
git commit -i "path/to/file/with/conflicts"
git rebase --abort
git commit .
git push --force origin "branch-name"

# Note that if you have multiple files, some that need to be merged but
# without changes, then the rebase needs to use --continue. If you only
# have files that are to be merged without changes, you can do the add
# and then use:
git rebase --skip
# However, if you have at least one merged file with changes and one or
# more merge files without changes, the skip will fail and the abort
# will reset all the changes. In that case you must use the continue.
# To get the continue to work, edit files that needed a merge but had
# no changes. Change something, save, and then:
git add "path/to/file/with/no/prior/changes/but/which/had/conflicts"
git rebase --continue
# The continue process may repeat itself a few times with the same or
# different files while git goes through your change history. Repeat
# the same thing until continue brings you back to your branch.
vim "...fix merge, apply a change if no merge..."
git add "path/to/file"
git rebase --continue
# repeat


# how to fix your branch and 'origin/master' have diverged
# it tells you there is a rebase problem, but you actually
# need to do a merge, not use the rebase command
# this happens quite a bit in the top module without any good
# reason (that is, there are multiple messages and their way
# to merge things is ... manual)
git merge origin/master
# -- verify that things look as expected --
git commit -a
git push origin master

# The following is an example of the failed push because of a "pretend" rebase
# # # $ git push origin master
# # #To git@github.com:m2osw/snapcpp.git
# # # ! [rejected]        master -> master (non-fast-forward)
# # #error: failed to push some refs to 'git@github.com:m2osw/snapcpp.git'
# # #hint: Updates were rejected because a pushed branch tip is behind its remote
# # #hint: counterpart. Check out this branch and integrate the remote changes
# # #hint: (e.g. 'git pull ...') before pushing again.
# # #hint: See the 'Note about fast-forwards' in 'git push --help' for details.


# And the following is about a conflict which is never really shown to you
# because the conflict is only in the "logs" and not in a file you manage!
# # # $ git status
# # #rebase in progress; onto 92cb30c
# # #You are currently rebasing branch 'master' on '92cb30c'.
# # #  (all conflicts fixed: run "git rebase --continue")
# # #
# # #Changes to be committed:
# # #  (use "git reset HEAD <file>..." to unstage)
# # #
# # #	modified:   snapwebsites





# cloning with submodules in one command
#
# WARNING: you must have an account with github or the sub-modules won't
#          load properly; the https://... method won't work with sub-
#          modules at this time
#
git clone --recursive git@github.com:m2osw/snapcpp


# If you already cloned the top module (snapcpp) then you can clone all
# submodules with the following command:
#
cd snapcpp
git submodule update --init --recursive


# To add a new submodule, simple use the add command with the URL of the
# submodule; the URL can be found in .git/config file of the submodule
# project directory.
#
git submodule add git@github.com:m2osw/snaplogger.git


# When checking the status of a parent module you may see the following
# message:
#
#   Changes not staged for commit:
#       modified:   snapwebsites (modified content)
#
# This means you need to commit data in that submodule and then commit
# that commit in the parent.
cd snapwebsites
git commit .
git push origin master
cd ..
git commit .
git push origin master


# Tagging to get a tag on github and automatically get a tarball/zip for
# people to download a specific version of our libraries, etc.
#
# Further reading: https://git-scm.com/book/en/v2/Git-Basics-Tagging
#
# FIRST MAKE SURE THAT THE VERSIONS ARE A GOOD MATCH BETWEEN
# THE debian/changelog AND THE CMakeLists.txt
#
# 'version' is our version such as 'v1.2.3'
#
git tag -a 'version' -m 'annotation'
git push origin 'version'

# Made a mistake? Delete and create a new one after you applied fixes as
# required...
#
git tag -d 'version'



# vim: syntax=sh
